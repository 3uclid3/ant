@startuml "ant::database (closed-world, archetype = table)"

/'==== Core IDs & ECS nouns ==== '/
class "ant::entity" as Entity {
  +uint32 index
  +uint32 generation
}

class "ant::component_id" as ComponentId
class "ant::table_id" as TableId

/'==== Schema (closed world) ==== '/
class "ant::schema" as Schema {
  +register<T>(name, version)
  +freeze_types()
  +component_id of(T): ComponentId
  --
  -map<string, ComponentId> name_to_id
  -vector<ComponentMeta> metas
}

class "ant::component_meta" as ComponentMeta {
  +size_t size
  +size_t align
  +ctor/dtor/move
  +growth_policy
  +uint64 version_tag
}

/'==== Signatures & directory ==== '/
class "ant::table_signature" as Signature {
  +bool has(ComponentId)
  +Signature add(ComponentId) : Signature
  +Signature remove(ComponentId) : Signature
  --
  -bitset<N> mask  ' closed-world lets this be fixed-width
}

class "ant::catalog" as Catalog {
  +TableId get_or_create(Signature)
  +const table& get(TableId) const
  --
  -unordered_map<Signature, TableId> sig_to_id
  -vector<table*> id_to_ptr
}

/'==== Storage ==== '/
class "ant::column" as Column {
  +void* data()
  +size_t size()
  +u32* versions()
  --
  -blocks
  -ComponentId cid
}

class "ant::table" as Table {
  +Signature signature()
  +span<Entity> entities()
  +Column& column(ComponentId)
  +ChunkIterator chunks()
  --
  -vector<Column> columns
  -vector<Entity> rows
}

class "ant::env" as Env {
  +bool has(ComponentId) const
  +void* get(ComponentId)
  +u32 version(ComponentId)
  --
  -unordered_map<ComponentId, byte[]> storage
  -unordered_map<ComponentId, u32> versions
}

/'==== Indices & clocks ==== '/
class "ant::entity_index" as EntityIndex {
  +bool alive(Entity) const
  +tuple<TableId, uint32 /*row*/> locate(Entity) const
  --
  -vector<TableId> table_of
  -vector<uint32> row_of
  -vector<uint32> generation_of
  -FreeList freelist
}

class "ant::clock" as Clock {
  +u32 world_tick
  +u32 next_tick()
}

/'==== Mutation pipeline ==== '/
class "ant::transaction_log" as TxLog {
  +append_insert(components...)
  +append_erase(entity)
  +append_attach(entity, components...)
  +append_detach(entity, types...)
  +append_replace(entity, components...)
  --
  -vector<Command> commands
}

class "ant::session" as Session {
  +insert(entity& out, components...)
  +erase(entity)
  +attach<T...>(entity, inits...)
  +detach<T...>(entity)
  +replace<T...>(entity, values...)
  --
  -TxLog* log
  -database* db
}

class "ant::alter_plan_cache" as AlterPlans {
  +Plan plan(Signature from, Signature to)
  --
  -unordered_map<pair<Signature,Signature>, Plan> cache
}

class "ant::committer" as Committer {
  +apply(database&, TxLog&)
}

/'==== Query path ==== '/
class "ant::select<...>" as Select {
  +shape() : QueryShape
  --
  -mask required_read
  -mask required_write
  -mask optional_read
  -mask without
}

class "ant::select_plan" as SelectPlan {
  +tables_with_all() : vector<TableId>
  +tables_with_missing_optionals() : vector<TableId>
  +make_cursor() : Cursor
  --
  -vector<TableId> bucket_with
  -vector<TableId> bucket_without
  -cached column ptrs
}

class "ant::cursor" as Cursor {
  +bool next_chunk()
  +tuple<spans...> chunk()
}

/'==== Database root ==== '/
class "ant::database" as DB {
  +schema& get_schema()
  +Session begin_session()
  +SelectPlan prepare(const Select&)
  +commit(Session&)
  --
  -Schema schema
  -Catalog catalog
  -EntityIndex entities
  -Env env
  -Clock clock
  -AlterPlans alter_plans
}

/'==== Relationships ==== '/
DB --> Schema : owns
DB --> Catalog : owns
DB --> EntityIndex : owns
DB --> Env : owns
DB --> Clock : owns
DB --> AlterPlans : owns

Catalog --> Table : manages
Table --> Column : owns *
Table --> Signature : has

EntityIndex --> Table : locates rows in
Schema --> ComponentMeta : provides
Signature --> ComponentId : composed-of

Session --> TxLog : writes to
Committer --> DB : mutates tables/index
Committer --> TxLog : consumes
Committer --> AlterPlans : uses for migrations
SelectPlan --> Catalog : resolves tables
Cursor --> Table : iterates chunks

@enduml
